{"meta":{"title":"别见黄花落的博客","subtitle":null,"description":null,"author":"别见黄花落","url":"https://stevenbz.github.io"},"pages":[],"posts":[{"title":"js中有关作用域的总结","slug":"js中的作用域的总结","date":"2018-01-14T12:17:35.000Z","updated":"2018-01-14T21:49:01.858Z","comments":true,"path":"2018/01/14/js中的作用域的总结/","link":"","permalink":"https://stevenbz.github.io/2018/01/14/js中的作用域的总结/","excerpt":"一、基本概念1.LHS与RHS引擎在变量查询时使用的方法。如果查找的目标是对变量进行赋值（查找左值），那么就会使用LHS查询，不成功的LHS引用会导致自动隐式地创建一个全局变量。如果目的是获取变量的值（查找非左值），就会使用RHS查询，不成功的RHS引用会导致抛出ReferenceError异常。 2.执行环境（execution context）执行环境定义了变量或函数有权访问的其他变量，决定了他们各自的行为。 3.变量对象（variable object）每个执行环境中都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。","text":"一、基本概念1.LHS与RHS引擎在变量查询时使用的方法。如果查找的目标是对变量进行赋值（查找左值），那么就会使用LHS查询，不成功的LHS引用会导致自动隐式地创建一个全局变量。如果目的是获取变量的值（查找非左值），就会使用RHS查询，不成功的RHS引用会导致抛出ReferenceError异常。 2.执行环境（execution context）执行环境定义了变量或函数有权访问的其他变量，决定了他们各自的行为。 3.变量对象（variable object）每个执行环境中都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 4.活动对象（activation object）变量对象被调用的时候就称之为活动对象。 5.作用域链（scope chain）当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象，活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中不存在，全局执行环境被认为是window对象） 二、ES5的函数作用域在ES5中是以函数为基本单位确定作用域的。如 123456789101112var a=1function func_1()&#123; var b=2 function func_2()&#123; var c=3 //这里可以访问a、b、c &#125; //这里可以访问b、c&#125;//这里可以访问a 三、关于闭包闭包是指有权访问另一个函数作用域中的变量的函数。 当某个函数被调用时会创建一个执行环境及相应的作用域链。 后台的每个执行环境都有一个表示变量的对象–变量对象。全局环境的变量对象始终存在，而函数的局部环境的变量对象则只在函数运行时存在。 在一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中。当内部函数从外部函数返回后，它的作用域链被初始化为包含外部函数的活动对象和全局变量对象。外部函数在执行完毕后，其执行环境的作用域链会被销毁，但是它的活动对象仍然会留存在内存中，因为内部函数的作用域链仍然在引用着这个活动对象。 如123456789function func()&#123; var result=new Array() for(var i=0;i&lt;10;i++)&#123; result[i]=function()&#123; return i &#125; &#125; return result&#125; 这里result数组中的每个成员函数都会返回10，因为每个成员函数的作用域链中都保存着func的活动对象，所以它们引用的是同一个变量i。 四、ES6中的块级作用域ES6中的let和const为JavaScript新增了块级作用域。 上面的代码可以使用let使得result的成员函数的行为符合预期。123456789function func()&#123; var result=new Array() for(let i=0;i&lt;10;i++)&#123; result[i]=function()&#123; return i &#125; &#125; return result&#125; 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。 块级作用域的特点：1、不存在变量提升12console.log(bar) //报错ReferenceErrorlet bar = 2 2、暂时性死区只要块级作用域内存在let或const命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 3、不允许重复声明 五、延长作用域链在ES5中使用with和try/catch的catch语块可以延长作用域链，即在作用域链的前端增加一个变量对象。 六、关于for循环for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 七、参考资料1、《JavaScript高级程序设计（第3版）》 2、《你不知道的JavaScript》 3、《ECMAScript 6入门》","categories":[],"tags":[]},{"title":"深入浅出React和Redux－读书笔记","slug":"深入浅出React和Redux读书笔记","date":"2017-11-28T10:17:35.000Z","updated":"2018-01-14T22:03:06.298Z","comments":true,"path":"2017/11/28/深入浅出React和Redux读书笔记/","link":"","permalink":"https://stevenbz.github.io/2017/11/28/深入浅出React和Redux读书笔记/","excerpt":"第一章 React新的前端思维方式React的理念，归结为一个公式，就像下面这样：UI=render(data) 让我们来看看这个公式表达的含义，用户看到的界面（UI），应该是一个函数（在这里叫render）的执行结果，只接受数据（data）作为参数。这个函数是一个纯函数。所谓纯函数，指的是没有任何副作用，输出完全依赖于输入的函数，两次函数的调用如果输入相同，得到的结果也绝对相同。如此一来，最终的用户界面，在render函数确定的情况下完全取决于输入数据。 React的新概念 JSX 所谓JSX，是JavaScript的语法扩展，让我们在JavaScript中可以编写像HTML一样的代码。 Virtual DOM 要了解Virtual DOM，就要先了解DOM，DOM是结构化文本的抽象表达形式，特定于Web环境中，这个结构化文本就是HTML文本，HTML中的每个元素都对应DOM中的某个节点，这样，因为HTML元素的逐级包含关系，DOM节点自然就构成了一个树形结构，称为DOM树。 既然DOM树是对HTML的抽象，那Virtual DOM就是对DOM树的抽象。Virtual DOM不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的Virtual DOM和上一次渲染的Virtual DOM，对比就会发现差别，然后修改真正的 DOM树时就只需要触及差别中的部分就行。","text":"第一章 React新的前端思维方式React的理念，归结为一个公式，就像下面这样：UI=render(data) 让我们来看看这个公式表达的含义，用户看到的界面（UI），应该是一个函数（在这里叫render）的执行结果，只接受数据（data）作为参数。这个函数是一个纯函数。所谓纯函数，指的是没有任何副作用，输出完全依赖于输入的函数，两次函数的调用如果输入相同，得到的结果也绝对相同。如此一来，最终的用户界面，在render函数确定的情况下完全取决于输入数据。 React的新概念 JSX 所谓JSX，是JavaScript的语法扩展，让我们在JavaScript中可以编写像HTML一样的代码。 Virtual DOM 要了解Virtual DOM，就要先了解DOM，DOM是结构化文本的抽象表达形式，特定于Web环境中，这个结构化文本就是HTML文本，HTML中的每个元素都对应DOM中的某个节点，这样，因为HTML元素的逐级包含关系，DOM节点自然就构成了一个树形结构，称为DOM树。 既然DOM树是对HTML的抽象，那Virtual DOM就是对DOM树的抽象。Virtual DOM不会触及浏览器的部分，只是存在于JavaScript空间的树形结构，每次自上而下渲染React组件时，会对比这一次产生的Virtual DOM和上一次渲染的Virtual DOM，对比就会发现差别，然后修改真正的 DOM树时就只需要触及差别中的部分就行。 第二章 设计高质量的React组件组件划分原则：高内聚、低耦合。 React组件的数据：React组件的数据分为两种：prop和state。无论prop 或者state的改变，都可以引发组件的重新渲染。React的prop：prop是从外部传递给组件中的数据，一个React组件通过定义自己能够接受的prop就定义了自己的对外公共接口。 React的state:state代表React组件的内部状态。由于React组件不能修改传入的prop，所以需要记录自身数据变化，就需要使用state。 组件的生命周期 React严格定义了组件的生命周期，生命周期可能会经历如下三个过程：装载过程（Mount），也就是把组件第一次在DOM树中渲染的过程；更新过程（Update），当组件被重新渲染的过程；卸载过程（Unmount），组件从DOM中删除的过程； 装载过程 当组件第一次被渲染时，依次调用的函数为constructor（初始化state、绑定成员函数的this环境）getInitialStategetDefaultProps(这两个函数的返回值用来初始化组件的state和props，只有用React.createClass方法创造的组件类才会发生作用)componentWillMountrender（最重要的函数，必须要实现，必须要是纯函数，在 render中修改state是错误的）componentDidMount（只能在浏览器端被调用，执行时React组件对应的DOM已经存在） 更新过程 当props或者state被修改的时候，就会引发组件的更新过程。更新过程会依次调用下面的生命周期函数，其中render函数和装载过程一样，没有差别。componentWillReceivePropsshouldComponentUpdatecomponentWillUpdaterendercomponentDidUpdate 卸载过程 componentWillUnmount React组件state和prop的局限数据如果出现重复，带来的一个问题就是如何保证重复的数据一致，如果数据存多份而且不一致，那就很难决定到底使用哪个数据作为正确结果了。 第三章 从Flux到ReduxFluxFlux是Facebook推出的一种单向数据流框架。我们知道，在实际的MVC框架实现中，总是允许View和Model可以直接通信，当业务逻辑变的复杂时，这种行为会导致复杂的依赖关系。Flux要求数据必须是单向流动的，从而避免这种错误的行为。一个Flux应用包含四个部分，它们分别是:Dispatcher，处理动作分发，维持Store之间的依赖关系；Store，负责存储数据和处理数据相关逻辑； Action，驱动Dispatcher的JavaScript对象；View，视图部分，负责显示用户界面 Flux的优点：单向数据流的管理方式，禁绝了数据流混乱的可能。Flux的不足：1、Store之间依赖关系 2、难以进行服务器端渲染 3、Store混杂了逻辑和状态 ReduxFlux的基本原则是“单向数据流”，Redux在此基础之上强调了三个基本原则：1、唯一数据源。2、保持状态只读。3、数据改变只能通过纯函数完成。在 Redux框架下，一个React组件基本上就是要完成以下两个功能：1、和Redux Store打交道，读取Store的状态，用于初始化组件的状态，同时还要监听Store的状态改变；当Store状态发生变化时，需要更新组件状态，从而驱动组件重新渲染；当需要更新Strore状态时，就要派发action对象；2、根据当前props和state渲染出用户界面 容器组件和傻瓜组件可以将这两个任务拆分给两个组件做，分别承担一个任务，然后把两个组件嵌套起来，完成原本一个组件完成的所有任务。外层组件是一个容器组件，内层组件是一个展示组件。展示组件就是一个纯函数，不需要有状态，即展示组件只需要根据props来渲染结果，不需要state。 组件context一个应用中，最好只有一个地方可以导入组件，这个位置当然应该是在调用最顶层React组件的位置。不让组件直接导入Store，那就只能让组件的上层组件把Store传递下来。首先想到的当然是用props，但是这种方法从上到下，所有的组件都要帮助传递这个props。设想在一个嵌套多层的组件结构中，只有最里层的组件才需要使用store，但是为了把store从最外层store从最外层传递到最里面，就要求中间所有组件都需要增加对这个store prop的支持，这无疑很麻烦。因此React提供了一个叫context的功能。上级组件要宣称自己支持context，并且提供一个函数来返回代表context的对象，然后这个上级组件之下的所有子孙组件，只要宣称自己需要这个context，就可以通过this.context访问到这个共同的环境对象。例如这个Provider组件： class Provider extends Component { getChildContext(){ return{ store:this.props.store }} render(){ return this.props.children;}} 为了让Provider能够被React认可为一个Context的提供者，还需要指定Provider的childContextType属性，代码为Provider.childContextTypes={ store:PropTypes.object}Provider还需要定义类的childContextTypes，必须和getChildContext对应，只有这两者都齐备，Provider的子组件才有可能访问到context子组件的contextTypes赋值和Provider.childContextTypes一样的值，两者必须一致，不然就无法访问到context，代码如下xxx.contextTypes={ store:PropTypes.object}在子组件中，所有对store的访问，都是通过this.context.store来完成的此外，构造函数要变为constructor(props,context){ super(props,context)} 在调用super的时候，一定要带上context参数注意：应该慎用context，因为全局变量会使程序变得难以控制。 React-Redux这个库实现了上面提到的2个改进React应用的方法。connect:连接容器组件和傻瓜组件，形式为 connect(mapStateToProps,mapDispatchToProps)(傻瓜组件)Provider:提供包含store的context，React-Redux要求store不仅是一个object，还必须是一个包含了三个函数的object，这3个object分别是subscribe,dispatch,getState。 第四章 模块化React和Redux应用按角色组织代码结构如MVC中把代码文件分别放在controllers,models,views文件夹中，有些React开发者会把代码分成reducers,actions,components,containers这些文件夹，这种做法并不可取。原因是每次修改一个功能时要在几个不同的文件夹之间跳转，对开发人员很不友好。 Redux应用适合按功能组织代码 在Redux中要注意一个状态节点只属于一个功能模块 Redux中提供了combineReducers把多个reducer组合起来 ref属性：当一个包含ref属性的React组件完成装载（mount）后，会看一看ref属性是不是一个函数，如果是一个函数，就会调用这个函数，参数就是这个组件代表的DOM元素。（注意：慎用这个属性，因为React的目的之一是远离DOM这个是非之地） JSX中可以使用任何形式的js表达式，但不能使用“语句”，因此for和while循环在JSX中是行不通的。 对于动态数量的子组件，每一个子组件都必须带上一个能够唯一标识这个组件的key属性 第五章 React组件的性能优化单个组件的性能优化React组件的更新原理是当组件渲染出Virtual DOM树后，与原来的Virtual DOM树进行比较来渲染不同的部分，虽然比原来的DOM树渲染性能有所优化，但是Virtual DOM树的建立和比较也要花费不少时间，这里就是优化的关键部分。React的shouldComponentupdate就是用来确定是否需要重新渲染的。 默认返回ture。react-redux的connect为容器组件自动重写了shouldComponentupdate，通过“浅比较”容器组件传给傻瓜组件的props是否变化来确定是否重新渲染。所谓“浅比较”就是用js中的===进行比较，对于简单props只比较值是否相同，对于复杂props则比较这两个props是不是同一个对象的引用。 多个组件的性能优化在比较Virtual DOM树时，为了提高效率，React采用了复杂度为O(N) 的比较方法，这种比较方法有一些缺陷，需要开发者帮助React变得更聪明。使用key在子组件中使用key可以让React识别子组件的位置，要注意的是，key应该是固定不变的，动态使用key（如使用数组下标作为key值）可能会让React “认错”子组件，这是非常危险的。 第六章 React高阶组件简单来说，一个高阶组件就是一个函数，这个函数接受一个组件作为参数，然后返回一个新的组件作为结果，而且这个新的组件具有原来的组件没有的功能。这里的组件不是组件实例，而是一个组件类或者无状态组件函数。关于高阶组件，有两种实现方式，一种是代理方式，另一种的继承方式。代理方式更容易实现和控制，继承方式的唯一优势是可以操纵特定组件的生命周期函数。和高阶组件相比，“以函数为子组件”的模式更加灵活。 第七章 Redux和服务器通信在React通常使用fetch来进行网络访问，fetch返回一个Promise对象。fetch的问题是只要服务器返回一个合法的HTTP响应就会认为响应成功，即使这个HTTP响应的状态码是代表出错的400或500.正因如此，我们在then中首先要检查传入参数response的status字段，只有status是代表成功的200时才继续，否则以错误处理。当response的状态码为200时，也不能直接读取response的内容，因为fetch在接收到HTTP响应的报头部分就会调用then。所以response.body返回的不是JSON，而是返回一个新的Promise。 利用代理功能解决跨域问题。 在React中在componentDidMount中进行网络访问 redux-thunkredux-thunk是Redux异步操作的解决方案之一。thunk是一个计算机编程术语，表示辅助调用另一个子程序的子程序。按redux-thunk的想法，在Redux的单向数据流中，在action对象被reducer函数处理之前，是插入异步功能的时机。redux-thunk的工作是检查action对象是不是函数，如果不是函数就放行，完成普通action对象的生命周期，而如果发现action对象是函数，那就执行这个函数，并把Store的dispatch函数和getState函数作为参数传递到函数中去，处理过程到此为止，不会让这个异步action对象继续往前派发到reducer函数。 第八章 单元测试只要应用得当，React和Redux应用的可测性非常高，因为对应单元测试写出来大多就是对纯函数的测试。单元测试框架：1 Mocha+断言库chai2 Facebook出品的Jest 辅助类： Enzyme2.sinon.js 第九章 扩展ReduxRedux之所以广受欢迎，就是因为社区围绕Redux创建了很多扩展功能，形成了一个生态系统。 中间件中间件的特点是：中间件是独立的函数中间件可以组合使用中间件有一个统一的接口 中间件处理的是 action对象，每个中间件都会接收到action对象，在处理完毕之后，就会把 action对象交给下一个中间件来处理，只有所有中间件都处理完action对象之后，才轮到reducer来处理action对象，然而，如果某个中间件觉得没有必要继续处理这个action对象了，就不会把action对象交给下一个中间件，对这个action对象的处理就此结束，也就轮不到reducer上场了。每个中间件必须要定义成一个函数，返回一个接收next参数的函数，而这个函数接收next参数的函数又返回一个接收action参数的函数。next参数本身也是一个函数，中间件调用这个next函数通知Redux自己的处理工作已经结束。 如：function doNothingMiddleware({dispatch,getState}){ return function(next){ return function(action){ return next(action)}}}中间件设计成这样的多层嵌套是因为Redux是根据函数式编程的思想来设计的，函数式编程的一个重要思想就是让每个函数的功能尽量小，然后通过函数的嵌套组合来实现复杂功能。 使用中间件两种方式：一、使用Redux提供的applyMiddleware来包装createStore产生一个新的创建Store的函数，以使用redux-thunk 为例：const configureStore=applyMiddleware(thunkMiddleware)(createStore)const store=configureStore(reducer,initialState)二、把applyMiddleware的结果当作Store Enhancer，和其它Enhancer混合之后作为createStore参数传入如：const storeEnhancer=compose(applyMiddleware(…middlewares))const store=createStore(reducer,storeEnhancers) StoreEnhancerRedux提供的创建Store的函数叫createStore,这个函数除了可以接受reducer和初试状体啊参数，还可以接受一个Store Enhancer参数，Store Enhancer是一个函数，这个函数接受一个createStore模样的函数为参数，返回一个新的createStore参数。一个什么都不做的Store Enhancer是这样的：const doNothingEnhancer=(createStore)=&gt;(reducer,preloadedState,enhancer)=&gt;{ const store=createStore(reducer,preloadedState,enhancer) return store}一个store对象中包含下列接口dispatchsubscribegetStatereplaceReducer每个接口都可以修改，当然无论如何修改，最后往往还是要调用原有对应的函数。 第十一章 多页面应用传统多页面应用切换页面的过程：1）浏览器的地址发生变化指向新的URL，于是浏览器发起一个HTTP请求到服务器获取页面完整的HTML2）浏览器获取到HTML内容后，解析HTML内容3）浏览器根据解析的HTML内容确定还需要下载哪些其它资源，包括JavaScript和CSS资源4）浏览器会根据HTML和其它资源渲染页面内容，然后等待用户的其他操作 而单页面应用要达到的目标是：1）不同页面之间切换不会造成网页的刷新2）页面内容和URL保持一致 React-Router是一个帮助我们创建React单页应用的工具。 集成Redux:Redux遵从的一个重要原则就是“唯一数据源”，唯一数据源并不是说所有的数据都要存储在一个地方，而是说一个特定数据只存在一个地方，以路由为例，使用React-Router，即使结合了Redux，当前路由的信息也是存储在浏览器的URL上，而不是像其他数据一样存储在Redux的Store上，这样做并不违背“唯一数据源”的原则，获取路由信息的唯一数据源就是当前URL。但是当利用Redux Devtools做测试时，无法重现网页之间的切换，因为当前路由作为应用状态根本没有在Store状态上体现，而Redux Devtools操纵的只有状态。为了克服这个缺点，我们可以利用react-router-redux库来同步浏览器URL和Redux的状态，虽然这违反了“唯一数据源”原则，但是只要两者绝对保持同步，就不会带来问题。 第十二章 同构服务器端渲染与浏览器端渲染服务器端渲染就是对于来自浏览器的 HTTP请求，服务器通过访问存储器或者访问别的API服务之类的方式获得数据，然后根据数据渲染产生HTML，浏览器只要把HTML渲染出来，就是用户想要看到的结果。浏览器端渲染就是由浏览器端完成路由结构与数据模板，生成HTML，只用API向服务器获取数据的模式。 React可以讲网页内容，动态行为和样式全部封装在一个组件中，把浏览器端渲染的应用发挥到极致。 网页性能指标：TTFP(Time To First Paint):指的是从网页HTTP请求发出，则用户可以看到第一个有意义的内容渲染出来的时间差。TTI(Time To Interactive):指的是从网页HTTP请求发出，到用户可以对网页内容进行交互的时间","categories":[],"tags":[]},{"title":"人工智能狂潮－读书笔记","slug":"人工智能狂潮－读书笔记","date":"2017-11-27T05:17:35.000Z","updated":"2018-01-10T03:18:29.944Z","comments":true,"path":"2017/11/27/人工智能狂潮－读书笔记/","link":"","permalink":"https://stevenbz.github.io/2017/11/27/人工智能狂潮－读书笔记/","excerpt":"第二章 四个级别的人工智能。 级别1 把单纯的控制程序称作 “人工智能”级别2 传统人工智能级别3 引入机器学习的人工智能级别4 引入深度学习的人工智能 哲学家John Searle提出的强人工智能与弱人工智能的区别：强人工智能：具备正确的输入与输出、被施与合理程序化的计算机，与拥有心智的人是没有任何区别的。弱人工智能：计算机没有必要拥有心智，只要能够通过其有限的智能解决一些智力问题即可。","text":"第二章 四个级别的人工智能。 级别1 把单纯的控制程序称作 “人工智能”级别2 传统人工智能级别3 引入机器学习的人工智能级别4 引入深度学习的人工智能 哲学家John Searle提出的强人工智能与弱人工智能的区别：强人工智能：具备正确的输入与输出、被施与合理程序化的计算机，与拥有心智的人是没有任何区别的。弱人工智能：计算机没有必要拥有心智，只要能够通过其有限的智能解决一些智力问题即可。第三章 第一次人工智能浪潮 出现于20世纪50年代后半期至20世纪60年代 1956年夏天，John McCarchy,Marvin Minsky,Allen Newell出席参加了美国东部达特茅斯学术会议，演示了由Newell和Simon共同研制的号称世界上第一个人工智能程序的“逻辑专家”，该程序能够自动对定理进行证明。 “推理与搜索”：推理是将人的思维过程用符号来表示，然后加以运行的方法，从处理方法来看，与搜索很接近。 “搜索”的例子：用搜索树探寻迷宫(DFS和BFS)、梵塔问题（河内塔问题）、机器人行动过程规划 两个秘诀：一、寻找更好的特征量。二、使用蒙特卡洛法改变评估机制 第四章 第二次人工智能浪潮 1964年被开发的人机对话系统－ELIZA 充分利用“知识”的专家系统：通过引入某个专业领域的知识，再经过推理，计算机便能够像该领域专家一样出色地展开工作。如20世纪70年代初由斯坦福大学开发的MYCIN “知识表示”1、人工智能研究初期诞生的“语义网”（Semantic Network）的研究，它是表示人的语义记忆方式的结构模型，它采用网络化结构的表达方式，在该模型里面，“概念”用节点来表示，节点之间通过链接方式进行串联。2、本体（ontology）研究，本体，是一个哲学术语，意思是“存在论”，作为人工智能术语，其被定义为“概念化的明确的规范说明”。其基本思路是，如同在制作信息系统时，需要有明确的规格说明书一样，在撰写知识时也需要有规格说明书。 重量级本体与轻量级本体认为人需要认真地考虑该怎么描述知识，并需研究为此应该怎么做，持这种观点的是“重量级本体论”者。把数据输进计算机里面，让计算机自己去寻找概念之间的相关性，持这种态度的是“轻量级本体论”者。 机器翻译的难点语言本身的语义歧义性要求翻译者有一般性常识，计算机要处理一般性常识，就需要掌握人类所拥有的、永远也无法写尽的海量知识，这无疑是极为困难的。计算机获取知识的这个难题，在人工智能领域被称作“知识获取瓶颈”。 框架问题由John McCarchy提出。即在执行任务时“仅仅提取出与它相关的知识并对其加以运用”，这对人类来讲是再简单不过的事情，然而对计算机来讲却困难无比。 符号接地问题由Steven Harnad提出。即是否能讲符号（词句、语言）与它所表示的意义连接起来的问题。 第五章 “机器学习”悄然兴起，第三次人工智能浪潮之一 统计自然语言处理（Statistical Natural Language Processing），它不考虑语法结构及上下文意思，只是机械地将对译概率较高的词语找出来组成句子即可，这是其基本思路。 “学习”即“区分”机器学习即指人工智能程序自身进行学习的机理，学习的主要工作其实就是进行“区分”作业，即对某一事物进行判断和识别。机器学习就是计算机一边处理大量的数据，一边自动学习这种“区分方法”。一旦它掌握了“区分方法”，它就可以利用它来对未知的数据进行“区分”。 有监督学习和无监督学习有监督学习（有师学习），指的是事先需要准备好输入与正确输出（区分方法）相配套的训练数据，让计算机进行学习，以便当它被输入某个数据时能够得到正确的输出（区分方法）。无监督学习（无师学习）则被运用于仅提供输入用数据、需要计算机自己找出数据内在结构的场合。其目的是让计算机从数据中抽取出其中所包含的模式及规则。","categories":[],"tags":[]}]}